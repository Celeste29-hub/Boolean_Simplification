https://github.com/Celeste29-hub/Boolean_Simplification.wiki.git

Welcome to the Boolean_Simplification wiki!

This project is designed to simplify Boolean expressions into DNF.

Atoms:
First, we start by defining out atoms. We use the regex library to seek any variable used in the Boolean expression and create a list of those variables. Once the variables have been identified, we assign them an integer value consistent with a truth table. We can think of our atoms as light switches that can be turned on or off.

Let's say that we have 3 variables in our boolean expression: i.e., a, b, c. Our truth table will be set up like this.

Minterms: F(a, b, c)
a' |b' |c': On or Off
a' |b' |c : On or Off
a' |b |c': On or Off
a' |b |c : On or Off
a |b' |c': On or Off
a |b' |c : On or Off
a |b |c': On or Off
a |b |c : On or Off

When we set up a Boolean expression, going back to the light switch example, we are essentially setting up a circuitry design for the light switches. This design controls what combinations of light switches, whether turned on or off, will cause a light bulb to also be turned on or off. So, for context, all of these light switches go to a single light bulb and not individual light bulbs. In this context, a single combination of light switches turn on or off, is considered a minterm.

For light switch A:
a' = Off
a = On 

This pattern applies to all of the light switches. The apostrophe indicates that a light switch is turned off. If it is not there, then the light switch is turned on!
Let's say, we set up a Boolean expression b. Then, we go to the truth table, and we find all of the combinations of light switches where light switch B is turn on. We define those as On and everything else as Off.

Minterms: F(a, b, c)
a' |b' |c': Off
a' |b' |c : Off
a' |b |c': On
a' |b |c : On
a |b' |c': Off
a |b' |c : Off
a |b |c': On
a |b |c : On

This means that the light will turn on with these combinations: a'bc', a'bc, abc', or abc. We would represent this expression by stringing together the minterms like this: a'bc' + a'bc + abc' + abc. In this case the + symbol represents an OR connective. It just mean that we are saying a'bc' or a'bc or... will allow for the light bulb to be turned on. This kind of representation is considered a Primary Disjunctive Normal Form (PDNF).

If we define a Boolean expression as a'b, then we set up a truth table where a is turned off, and b is turned on.

Minterms: F(a, b, c)
a' |b' |c': Off
a' |b' |c : Off
a' |b |c': On
a' |b |c : On
a |b' |c': Off
a |b' |c : Off
a |b |c': Off
a |b |c : Off

We can represent this as a'bc' + a'bc.

If we define a Boolean expression as c + a'b then we set up a truth table where c is turned on or where a is turned off and b is turned on.

Minterms: F(a, b, c)
a' |b' |c': Off
a' |b' |c : On
a' |b |c': On
a' |b |c : On
a |b' |c': Off
a |b' |c : On
a |b |c': Off
a |b |c : On

In this example, we can represent the expression as a'b'c + a'bc' + a'bc + ab'c + abc.

Using a truth table, we have the options to use on or off, true or false, 1 or 0, or anything we wish to represent the light bulb as being turned on or off. It doesn't matter what we choose as the representation, as long as we (the audience) understand the representation.

Each Boolean expression has an index value. The index value represents all of the combinations of switches turned on or off, and it's corresponding output! Will the light bulb turn on or off? For the expression c + a'b, the binary index value is 10101110. When we go back through the table, we move from the bottom of the table up. 1 represents on, and 0 represents off. We can convert that number from binary to decimal and get a decimal index value for the truth table. In this case 10101110 in binary is equal to 174. Therefore, our decimal index value for c + a'b is equal to 174.

When utilize the same process to identify the index values for our atoms: a, b, c, we find that:

a = 240
b = 204
c = 170

These index values are very important for our boolean expression simplifier, because we will be performing bitwise operations to simplify our boolean expressions.

String parsing:
This program is designed to take a string as an input to increase the versatility of this program. We will need to parse the string in order to identify the Boolean Index Value of the expression.

Once we've identified the index values of the atoms, we replace the atoms in the string with its corresponding value. Then we perform bitwise operations on the string. Once we've identified a final solution, we can then therefore set up a Truth Table!

For example: c + a'b = 10101110 in binary form or 174 in decimal form!

Minterms: F(a, b, c)

a' |b' |c': 0
a' |b' |c : 1
a' |b |c': 1
a' |b |c : 1
a |b' |c': 0
a |b' |c : 1
a |b |c': 0
a |b |c : 1

This is an earlier example. So far, we've completed 3 steps.
We identify the index values for the atoms.
We parse the string and the index value for the expression
We set up the truth table! Now, we identify the PDNF for the expression as a'b'c + a'bc' + a'bc + ab'c + abc.
Prime implicants:
A prime implicant represents a set of minterms, the combinations of switches turn on or off, in it's smallest form.

An implicant literal represent a single switch turned on or off. For the atom a, the two implicant literals are a' and a.

In this case, we go through each minterm in our PDNF, find the combinations of those minterms by the Implicant Literals.

a' covers a'b'c, a'bc', and a'bc

Finding all the prime implicants, we get:

a': [a'b'c, a'bc', a'bc]
b': [a'b'c, ab'c]
c': [a'bc']
a: [ab'c, abc]
b: [a'bc', abc]
c: [a'b'c, a'bc, ab'c, abc]
a'b': [a'b'c]
a'b: [a'bc', a'bc']
ab': [ab'c]
ab: [abc]
a'c': [a'bc']
a'c: [a'b'c]
ac: [abc]
b'c: [a'b'c, ab'c]
bc': [a'bc']
bc: [abc]
a'b'c: [a'b'c]
a'bc': [a'bc']
a'bc: [a'bc]
ab'c: [ab'c]
abc: [abc]

Filtering them, we identity that:
If they have 1 implicant literal, then there should cover 4 minterms.
If they have 2 implicant literals, then they should cover 2 minterms.
If they have 3 implicant literals, then they should only cover 1 minterm.

We get:
c: [a'b'c, a'bc, ab'c, abc]
a'b: [a'bc', a'bc]
b'c: [a'b'c, ab'c]
a'b'c: [a'b'c]
a'bc': [a'bc']
a'bc: [a'bc]
ab'c: [ab'c]
abc: [abc]

We then group the prime implicants by the number of implicant literals. 
1: [c] 
2: [a'b, b'c] 
3: [a'b'c, a'bc', a'bc, ab'c, abc]

Solving:
Once we have identified all of the prime implicants, filtered and grouped them, we then move through the groupings, one by one, and set up our DNF!

So, we set up a temporary set that we will fill without our minterms as we identify the prime implicants used in our DNF.

The goal is to identify the prime implicant whose minterms they cover, has the least number overlapping with the temporary set.

First, the temporary set is empty, we start with the very first prime implicant in the iteration process. 
DNF = c 
Temp = {a'b'c, a'bc, ab'c, abc}

Secondly, we gauge whether or not this solution covers our full PDF. If not, we move forward to the next step. Since our PDNF has 5 element, we know that it does not!

Thirdly, now temp has 4 elements. We go to the second iteration and we look at the two prime implicants we have available. 
a'b: [a'bc', a'bc] 
b'c: [a'b'c, ab'c]

Overlappings: 
a'b: 1 
b'c: 2

Since a'b only has one overlapping element and because not all of a'b is in temp, we add a'b to DNF. 
DNF = c + a'b 
Temp = {a'b'c, a'bc', a'bc, ab'c, abc}

Now, because all of the elements in temp is in DNF, we can terminate the program early and output DNF as our solution!